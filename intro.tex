\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}% Change the margins here if you wish.
\usepackage{amsmath,amsthm,amssymb,stmaryrd}
\usepackage[english]{babel}
\setlength{\parindent}{0pt} % This is the set the indent length for new paragraphs, change if you want.
\setlength{\parskip}{5pt} % This sets the distance between paragraphs, which will be used anytime you have a blank line in your LaTeX code.
\usepackage[textwidth=1.9cm,textsize=small]{todonotes}
\usepackage{hyperref}

\newcommand{\ifilip}[1]{\todo[inline,color=green!10]{{\bf Filip:} #1}}
\newcommand{\filip}[1]{\todo[color=green!10]{{\bf Filip:} #1}}

\newcommand{\iolek}[1]{\todo[inline,color=red!10]{{\bf Olek:} #1}}
\newcommand{\olek}[1]{\todo[color=red!10]{{\bf Olek:} #1}}

\usepackage[capitalise]{cleveref}

\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]
\newtheorem{theorem}{Theorem}[section]
\newtheorem{corollary}{Corollary}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{example}{Example}[section]

\title{Sequences definable by 1-letter quantitative logics}
\author{Aleksander Wisniewski}
\date{\today}

\begin{document}
\maketitle

\section{Introduction}
It is an important result in computer science that the class of languages defined by finite automata coincides with the languages defined using MSO logic~\cite{Buchi1960}. Finite automata allow us to recognize languages, i.e., to accept or reject words over a given alphabet. Sch{\"{u}}tzenberger~\cite{Schutzenberger61b} extended the model of finite automata to make it possible to calculate quantitative properties of words. He introduced a model of weighted automata, which have richer semantics than finite automata. In weighted automata, transitions are supplied with weights (values from a semiring) and weights along a fixed run are multiplied using the semiring product. A value corresponding to a given input word is the semiring sum of values over all runs. Weighted automata calculate what we call a formal power series: a function from words to the semiring domain, $S: \Sigma^* \rightarrow K$.

Manfred Droste and Paul Gastin introduced a logic that coincides with weighted automata~\cite{DrosteG07}, in the same spirit as MSO logic coincides with finite automata. Their logic is called \emph{weighted logic}, and its semantics allows defining formal power series like weighted automata do. Unfortunately, the full ``natural'' form of weighted logic is richer than weighted automata, so the authors had to restrict the class of weighted logic expressions in order to capture the same expressiveness as weighted automata. The restrictions are both at the syntactic and semantic levels.

A follow up work on weighted logics is the work of Stephan Kreutzer and Cristian Riveros~\cite{KreutzerR13}. In their work, they introduced QMSO logic - Quantitative Monadic Second Order logic, which fulfills similar goals to the weighted logics of Manfred Droste and Paul Gastin but with easier definitions and a clearer distinction between the logical level (MSO) and the semiring level (addition/multiplication). They also had to restrict their logic to achieve the same power of expression as weighted automata, but their restriction is only at the syntactic level.

In this work, we explore the world of unrestricted QMSO expressions. More precisely, we will look into the properties of formal power series defined by unrestricted QMSO over a one-letter alphabet. Assume our alphabet is $\Sigma = \{a\}$. In this case words can be identified with their length. Thus the formal power series $S: \Sigma^* \rightarrow K$ can be seen as a sequence $S: \mathbb{N} \rightarrow K$, by mapping words $a^n$ to their length $n$. Restricted QMSO expressions coincide with weighted automata, and it is folklore that formal power series defined by weighted automata over a one-letter alphabet are exactly linear recursive sequences (see e.g.~\cite{BarloyFLM22}). It can be easily shown that sequences achieved using unrestricted QMSO form a richer class than linear recursive sequences, which was already demonstrated in~\cite{CadilhacMPPS20}, but this class has not been investigated beyond that.

\paragraph*{Our contributions}
In this work, we introduce the notation of \textbf{1Q} sequences - sequences defined by unrestricted QMSO expressions over a one-letter alphabet. In Section~\ref{Sec1QRateOfGrowth}, we prove that the rate of growth of such sequences is at most doubly exponential, and this bound can be achieved. Then, in Section~\ref{Sec1QFiniteSemirings}, we prove results about 1Q sequences over finite semirings - namely, that it is possible to simplify corresponding QMSO expressions by removing semiring quantifiers. From this, we deduce that 1Q sequences are eventually periodic modulo, which in particular implies that the Catalan sequence is not a 1Q-definable sequence.
\ifilip{To musi byc dluzsze. Trzeba jakos opisac co bylo wiadomo, co dokladnie zrobiles itp. Ale moze wrocimy do tego na koniec}

\paragraph*{Related work}
In~\cite{CadilhacMPPS20}, a class of polynomial recursive sequences is defined. It is an extension of linear recursive sequences, and this class enables defining sequences with doubly exponential growth. In~\cite{CadilhacMPPS20}, it is shown that 1Q sequences can define a sequence that is undefinable as a polynomial recursive sequence: $n^n$. However, whether the converse inclusion holds is not clear, namely if every polynomial recursive sequence can be defined as a 1Q sequence?

There are other classes of sequences researched that extend linear recursive sequences, such as rational recursive sequences~\cite{ClementeDMP23} or holonomic sequences~\cite{KenisonKLLMOW021}. However, these classes can define Catalan sequences, while 1Q sequences cannot.

In the original paper by Manfred Droste and Paul Gastin~\cite{DrosteG07}, it is shown that weighted logics (unrestricted) over finite semirings coincide with weighted automata. From this, it is possible to deduce that 1Q sequences are eventually periodic modulo, but we present different proof methods. In particular, we do not introduce the notation of weighted automata.

% First about weighted automata, Schutzenberger~\cite{Schutzenberger61b}
% In \textit{Weighted automata and weighted logic} Manfred Droste and Paul Gastin introduced weighted logics.~\cite{DrosteG07,KreutzerR13} Expressions of weighted logics make it possible to express quantitative properties of finite automata. In particular there is a subclass of weighted logics that can represent weighted automata. 

% The point of WMSO: to have a BÃ¼chi-Elgot-Trakhtenbrot theorem. Sort of worked, sort of didn't.

% There are other characterisations/generalisation via CRA/polynomial automata~\cite{Senizergues07,AlurDDRY13,BenediktDSW17}.

% Also subclasses: bounded ambiguity~\cite{WeberS91,KreutzerR13} copyless CRA~\cite{AlurDDRY13}

% Typical problems: equivalence/zeroness in ptime~\cite{Schutzenberger61b}, decidable even for CRA~\cite{BenediktDSW17}

% Output of weighted logic expression over some word is a value from a semiring, so it defines a formal power series. We're interested in a subclass of weighted logic expressions on words over one letter alphabet. This way a weighted logic expression will define a sequence of numbers - $n$-th number in a sequence will be the output of the expression on a word of length $n$. In particular it's possible to define all linear recursive sequences in weighted logic expressions: linear recursive sequences can be defined using weighted automata, and weighted automata can be defined using weighted logic expressions.

% LRS survey~\cite{OuaknineW15}
% Connections of weighted automata and LRS~\cite{BarloyFLM22,CadilhacMPPS20}. (Interesting) Results obtained from such analysis.

% \paragraph*{Our contributions}

% In this work we'll look at sequences that can be defined using weighted logic expressions over one letter alphabet. We know that class of linear recursive sequences is contained in this class and we can easily prove that this containment is strict. We'll compare this class of sequences to class of polynomial recursive sequences. We'll look at possible speed of growth of these sequences and try to analyze its various properties, like behaviour modulo or whether we can easily check if it's constantly equal to zero.

% \ifilip{It should be clear how it compares with previous work, e.g.\ what was known, \cite{CadilhacMPPS20} discusses similar problems}

% \paragraph*{Related work}

% E.g.\ ~\cite{ClementeDMP23} where rational recursive sequences are defined. They still cannot define $n^n$, but they can define Catalan so they are not periodic. Maybe holonomic sequences~\cite{KenisonKLLMOW021}

\section{Preliminaries}
In this section we present the syntax and semantics for Quantitative Monadic Second Order Logic (QMSO). It was introduced in~\cite{KreutzerR13} by Stephen Kreutzer and Cristian Riveros. Our presentation is based directly on this work. Then we will focus on 1Q sequences and provide some examples.

\subsection{Linear Recursive Sequences}
A sequence over a set $\mathbb{D}$ is a function $a : \mathbb{N} - \{0\} \rightarrow \mathbb{D}$.

Linear recursive sequences (\emph{LRS}) are sequences satifsfying following recurrence relation:
$$a(n) = c_1 a(n-1) + c_2 a(n-2) + \ldots + c_k a(n-k),$$
where $c_1,\ldots,c_k$ are constants. In this work we focus mostly on natural numbers, so we assume that $c_1,\ldots ,c_k \in \mathbb{N}$.

\begin{example}[Fibonacci sequence]
    One of the most poular linear recursive sequences is Fibonacci sequence, satisfying following reccurence:
    $$a(n) = a(n-1) + a(n-2),$$
    starting from $a(1) = 0$, $a(2) = 1$.
\end{example}

\subsection{Monadic Second Order Logic}

Let $\Gamma$ be a finite alphabet. The syntax of MSO over a finite alphabet $\Gamma$ is given by:
$$ \varphi := P_a(x) \ | \ x \leq y \ | \ x \in X \ | \ (\varphi \lor \varphi) \ | \ \neg \varphi \ | \ \exists x. \varphi \ | \ \exists X . \varphi, $$
where: $a \in \Gamma$; $x, y$ are first-order variables; and $X$ is a second order variable. Universal quantification can be obtained from existential quantification and negation. We can also use syntactic sugar $\land$ and $\implies$ as usual.

Let $w = w_1\ldots w_n \in \Gamma^*$ be a word of length $|w| = n$. We represent $w$ as a structure $(\{1,\ldots,n\}, \leq, (P_a)_{a \in \Gamma})$ where $P_a = \{i \ | \ w_i = a\}$. We denote by $Dom(w) = \{1,\ldots,n\}$ the domain of $w$ as a structure. Given a finite set $V$ of first-order and second-order variables, a $(V,w)$-assignment $\sigma$ is a function that maps every first order variable in $V$ to $Dom(w)$ and every second order variable in $V$ to $2^{Dom(w)}$. Furthermore, we denote by $\sigma[x \rightarrow i]$ the extension of the $(V,w)$-assignment $\sigma$ such that $\sigma[x \rightarrow i](x) = i$ and $\sigma[x \rightarrow i](y) = \sigma(y)$ for all variables $y \ne x$. The assignment $\sigma[X \rightarrow I]$, where $X$ is a second-order variable and $I \subseteq Dom(w)$, is defined analogously. Consider an MSO-formula $\varphi$ and a $(V,w)$-assignment $\sigma$ where $V$ is the set of free variables of $\varphi$. We write $(w, \sigma) \models \varphi$ if $(w, \sigma)$ satisfies $\varphi$ using the standard MSO-semantics.

\subsection{Semirings}

A semiring signature $\xi := (\oplus, \odot, 0, 1)$ is a tuple containing two binary function symbols $\oplus, \odot$, where $\oplus$ is called the addition and $\odot$ the multiplication, and two constant symbols $0$ and $1$. A semiring over the signature $\xi$ is a $\xi$-structure $\mathbb{S} = (S, \oplus, \odot, 0, 1)$, where $(S, \odot, 0)$ is a commutative monoid, $(S, \odot, 1)$ is a monoid, multiplication distributes over addition, and $0 \odot s = s \odot 0 = 0$ for each $s \in S$. If the multiplication is commutative, then we say that $\mathbb{S}$ is commutative.

Semirings we will be interested in in this paper include:

\begin{itemize}
    \item semiring of natural numbers: $\mathbb{N} = (\mathbb{N}, +, \cdot, 0, 1)$
    \item finite semirings of numbers modulo arbitrary $k$: $ \mathbb{Z}_k = (\{0,1,\ldots,k-1\}, +_{mod}, \cdot_{mod}, 0, 1)$ where operations are executed modulo $k$
\end{itemize}

We restrict ourselves to sequences over natural numbers, although 1Q sequences can be defined over arbitrary semirings.

\subsection{Quantitative Monadic Second-Order Logic}

\textbf{(Syntax)} The formulas of Quantitative Monadic Second-Order Logic (QMSO) over a semiring $\mathbb{S}$ and a finite alphabet $\Gamma$ (QMSO[$\mathbb{S}, \Gamma$]) are defined by the following grammar:
$$ \theta := \varphi \ | \ s \ | \ (\theta \oplus \theta) \ | \ (\theta \odot \theta) \ | \ \Sigma_x \ \theta \ | \ \Pi_x \ \theta \ | \ \Sigma_X \ \theta \ | \ \Pi_X \ \theta,$$
where: $\varphi \in MSO[\leq, (P_a)_{a \in \Gamma}]$; $s \in \mathbb{S}$; $x$ is first-order variable; and $X$ is a second-order variable.

\textbf{(Semantics)} Let $w 
= w_1 \dots w_n \in \Gamma^*$ where $n = |w|$. For the Boolean level $\varphi$, the semantics is the usual semantics of MSO, i.e. for any assignment $\sigma$,
\begin{equation*}
    \llbracket\varphi\rrbracket(w, \sigma) =
      \begin{cases}
        1 & \text{if $(w, \sigma) \models \varphi$}\\
        0 & \text{otherwise}
      \end{cases}       
\end{equation*}

The semantics of the semiring level is defined as follows:

$$\llbracket s\rrbracket(w, \sigma) := s$$
$$\llbracket(\theta_1 \oplus \theta_2)\rrbracket(w, \sigma) := \llbracket\theta_1\rrbracket(w, \sigma) \oplus \llbracket\theta_2\rrbracket(w, \sigma)$$
$$\llbracket(\theta_1 \odot \theta_2)\rrbracket(w, \sigma) := \llbracket\theta_1\rrbracket(w, \sigma) \odot \llbracket\theta_2\rrbracket(w, \sigma)$$
$$\llbracket \Sigma_x \ \theta \rrbracket(w, \sigma) := \oplus^n_{i=1}\llbracket \theta \rrbracket (w, \sigma[x \rightarrow i])$$
$$\llbracket \Pi_x \ \theta \rrbracket(w, \sigma) := \odot^n_{i=1}\llbracket \theta \rrbracket (w, \sigma[x \rightarrow i])$$
$$\llbracket \Sigma_X \ \theta \rrbracket(w, \sigma) := \oplus_{I \subseteq [1,n]}\llbracket \theta \rrbracket (w, \sigma[X \rightarrow I])$$
$$\llbracket \Pi_X \ \theta \rrbracket(w, \sigma) := \odot_{I \subseteq [1,n]}\llbracket \theta \rrbracket (w, \sigma[X \rightarrow I])$$

We will call sum ($\Sigma$) and product ($\Pi$) quantifiers \emph{semiring quantifiers}, as opposed to quantifiers at MSO level $\exists$, $\forall$. Semiring quantifiers can be thought of in following way: we iterate over all valuations of variable bound by quantifier (first order or second order) and calculate value of inner expression for given valuation. Then we sum (for $\Sigma$) or multiply (for $\Pi$) those values.

\begin{example}
    A simplest example of semiring quantifier usage is an expression that counts the number of occurrences of letter $a$ in a word:
    $$\Sigma_x \ P_a(x)$$
    We iterate over all positions ($x$) in word, check if there is letter $a$ on given position ($P_a(x)$). Inner expression returns $1$ if there is, $0$ otherwise. 
\end{example}

\subsection{QMSO over one letter alphabet}

In this work, we focus on expressions of QMSO logic over a one-letter alphabet. We call these expressions \emph{1Q expressions}. In this case, we only use a fragment of MSO logic; in particular, we do not need letter predicates $(P_a)_{a \in \Gamma}$, as there is only one such predicate and it is true for every element of the structure. For simplicity we assume that our one-letter alphabet is always $\Gamma = \{a\}$.

1Q expressions with no free variables (1Q sentences) generate sequences of numbers. Suppose we have a 1Q sentence $\varphi$, then we can generate corresponding sequence $a(n) = \llbracket \varphi \rrbracket (a^n, \sigma)$, where $\sigma$ is an empty valuation function (there are no free variables). The class of sequences definable 1Q expressions is called \emph{1Q sequences}.

In~\cite[Section IV]{KreutzerR13}, Stephan Kreutzer and Cristian Riveros introduced a fragment of QMSO logic called Quantitative Iteration Logic (QIL). This syntatic fragment imposes restrictions on quantifier alternations: there can be an arbitrary number of $\Sigma$ quantifiers used, and then $\Pi$ quantifier over first order variable. After $\Pi$ there can only be quantifier-free expression. They prove following theorem, which will be an important result for us:

\begin{theorem}
\label{QILWL}
    A function $f: \Gamma^* \rightarrow S$ is definable by a weighted automaton over $S$ and $\Gamma$ iff $f$ is definable by a formula in QIL, and this translation is effective.
\end{theorem}

We won't go into details defining weighted automata. What's important is that it is folklore that formal power series defined by weighted automata over a one-letter alphabet are exactly linear recursive sequences (see e.g.~\cite{BarloyFLM22}). From this follows that all LRS are 1Q-definable.

Below we present some examples of 1Q sequences.

\begin{example}[Factorial]
\label{ExSeqFactorial}
    The sequence $a(n) = n!$ can be defined with the following 1Q expression: 
    $$\Pi_{x_1}\Sigma_{x_2} \ (x_2 \leq x_1) \cdot 1.$$

    For given $n$ it works as following: $x_1$ iterates over $1,\ldots,n$. For fixed $x_1 = k$ the expression $\Sigma_{x_2} \ (x_2 \leq x_1) \cdot 1$ evaluates to $k$. So the whole expression evaluates to $1 \cdot 2 \cdot \ldots \cdot n = n!$.
\end{example}

\begin{example}[Super exponential]
\label{ExSeqNToN}
    Similarly as in \Cref{ExSeqFactorial} the sequence $a(n) = n^n$ can be defined with the following 1Q expression:
    $$\Pi_{x_1}\Sigma_{x_2} \ 1.$$
\end{example}

\begin{example}[Doubly exponential]
\label{ExSeqDoubleExponential}
    The sequence $a(n) = 2^{2^n}$ can be defined with 1Q expression:
    $$\Pi_{X_1} \ 2.$$

    For a fixed $n$, there are $2^n$ possible choices of $X_1$. So $2$ is multiplied $2^n$ times, which gives results in $2^{2^n}$.
\end{example}

\section{1Q sequences rate of growth}
\label{Sec1QRateOfGrowth}
Let $a(n)$ be a 1Q sequence over natural numbers. We would like to find an upper bound for the asymptotical behavior of $a(n)$ depending only on $n$ and constants appearing in the 1Q expression defining it. We will identify the class of sequences bounding 1Q sequences as the \emph{rate of growth} of these sequences. So a 1Q sequence $a(n)$ will have a rate of growth in class of sequences $B$ if $\exists_{b \in B} \exists_{N \in \mathbb{N}} \exists_{k \in \mathbb{N}} \forall_{n \geq N} \ a(n) \leq k \cdot b(n)$.

We start by discussing linear recursive sequences (LRS).
%
It is known that linear recursive sequences have an exponentially bounded rate of growth. More formally, if $a(n)$ is an LRS then $|a(n)| \le 2^{O(n)}$. In \cref{ExSeqFactorial} we saw that in 1Q one can define the sequence $n!$ for which, by Stirling's approximation, we know that $n! = \Omega((\frac{n}{e})^n)$, exceeding the $2^{O(n)}$ bound for LRS. This shows that the class of 1Q sequences contains a sequence not definable in LRS. As mentioned in previous section (\ref{QILWL}), linear recursive sequences are contained in class of 1Q-definable sequences. From this follows that class of 1Q-definable sequences is strictly richer than LRS.

By \cref{ExSeqNToN} and \cref{ExSeqDoubleExponential}, it is clear that it is possible to define 1Q sequences with a rate of growth even larger than $n!$. We want to provide an upper bound for the rate of growth for all 1Q sequences.
We will prove that the rate of growth of 1Q sequences is bounded by $2^{2^{O(n)}}$. First, we will prove a lemma, which will be useful to simplify QMSO expressions without semiring quantifiers.

\begin{definition}[Recognizable step function]
    \label{DefRecStepFun}
    Fix a semiring $K$.
    A series $S: A^* \rightarrow K$ is a \textit{recognizable step function}, if $S = \sum_{i = 1}^{n} \ \varphi_{L_i} \cdot k_i$\filip{suma w sensie polpierscienia? (alek) tak} for some $n \in \mathbb{N}$, $k_i \in K$ and regular languages $L_i \subseteq A^*$ ($i=1,\ldots,n$). $\varphi_{L_i}$ is an MSO formula recognizing language $L_i$.
\end{definition}

\begin{lemma}
    \label{QFreeRecognizable}
    Let $\theta$ be a QMSO expression without semiring quantifiers. Then $\theta$ can be expressed as a recognizable step function.
\end{lemma}

\begin{proof}
    We prove it by induction on the structure of expressions.
    First, consider base cases:
    \begin{enumerate}
        \item QMSO expression $\theta = \varphi$, where $\varphi$ is a MSO expression. The corresponding recognizable step function is $\theta = \varphi \cdot 1$;
        \item QMSO expression $\theta = k$, where $k \in K$. The corresponding recognizable step function is $\theta = \varphi \cdot k$, where $\varphi$ recognizes the whole language (for example, $\varphi = \exists_x \ x = x$).
    \end{enumerate}

    We proceed with the induction step. We consider two cases: addition and multiplication.
    \begin{enumerate}
        \item Let $\theta_1, \theta_2$ be recognizable step functions. Then $\theta_1 + \theta_2$ is a recognizable step function. It is immediate from definition.
        \item Let $\theta_1 = \sum_{i = 1}^{n_1} \ \varphi_{L_{1,i}} \cdot k_{1,i}, \theta_2 = \sum_{i = 1}^{n_2} \ \varphi_{L_{2,i}} \cdot k_{2,i}$ be recognizable step functions. Then $\theta = \theta_1 \cdot \theta_2$ is a recognizable step function. Namely, $\theta$ is a sum of following expressions: $\varphi_{1,i} \cdot k_{1, i} \cdot \varphi_{2,j} \cdot k_{2,j}$. It can be rewritten in following way: $(\varphi_{1,i} \land \varphi_{2,i}) \cdot (k_{1,i} \cdot k_{2,j})$, from which it is immediate that $\theta$ is a recognizable step function.
    \end{enumerate}
This concludes the proof.
\end{proof}

\begin{lemma}[1Q growth rate class]
    The growth rate class of 1Q sequences is doubly exponential, i.e.\ $2^{2^{O(n)}}$.\filip{chcialbym defnicje growth rate w preliminaries (alek) poki co napisalem cos na poczatku sekcji, nadal troche nie wiem jak to dobrze napisac} Moreover, for every $k, c \in \mathbb{N}$ it is possible to define a 1Q sequence such that $a_n = c^{2^{kn}}$.\filip{tu juÅ¼ ustalamy polpierscien na liczby naturalne? (alek) tak bedzie wygodniej, ale teoretycznie nie musimy}
\end{lemma}

\begin{proof}
    Every sequence generated by 1Q expression can be bounded by a sequence defined by a sequence defined by 1Q expression of following form: $\Pi_{X_1}\Pi_{X_2}\ldots \Pi_{X_k} \ c$, where $X_i$ are second order quantifiers and $k \geq 0$ (for $k = 0$ there are no quantifiers, only constant $c$). We will prove it by induction on structure of 1Q expressions.

    For base case, consider quantifier-free expression $\varphi$. Thanks to lemma~\ref{QFreeRecognizable} we know that such an expression can be simplified to recognizable step function $\varphi = \sum_{i = 1}^{n} \ \varphi_{L_i} \cdot k_i$. Each of $\varphi_{L_i}$ is either $0$ or $1$. Set $c = \sum_{i=1}^n \ k_i$. Clearly $\sum_{i = 1}^{n} \ \varphi_{L_i} \cdot k_i \leq  \sum_{i=1}^n \ k_i = c$. Additionally, let us assume that $c$ is not smaller than $2$, i.e.\ $c = max(2, \sum_{i=1}^n \ k_i)$. This will help with further steps.

    Let $\varphi_1 = \Pi_{X_1'}\ldots \Pi_{X_k'} \ c_1$, $\varphi_2 = \Pi_{X_1''}\ldots \Pi_{X_k''} \ c_2$ be two 1Q expressions. In general, an expression of form $\Pi_{X_1}\ldots \Pi_{X_k} \ c$ defines sequence $a(n) = c^{2^{nk}}$. Denote by $a_1(n)$, $a_2(n)$ sequences defined by expressions $\varphi_1$ and $\varphi_2$, respectively. Then $a_1(n) = (c_1)^{2^{k'n}}$, $a_2(n) = (c_2)^{2^{k''n}}$. Sequences defined by both $\varphi_1 + \varphi_2$ and $\varphi_1 \cdot \varphi_2$ can be bounded by a sequence $a_3(n)$ defined by a 1Q expression $\varphi_3 = \Pi_{X1'} \ldots \Pi_{Xk'} \Pi_{X1''} \ldots \Pi_{Xk''} \ c_1 \cdot c_2$:

    $$a_1(n) + a_2(n) = (c_1)^{2^{k'n}} + (c_2)^{2^{k''n}} \leq (c_1 \cdot c_2)^{2^{(k' + k'')n}} = a_3(n),$$
    and
    $$a_1(n) \cdot a_3(n) = (c_1)^{2^{k'n}} \cdot (c_2)^{2^{k''n}} \leq (c_1 \cdot c_2)^{2^{(k' + k'')n}} = a_3(n),$$
    which is true assuming $c \geq 2$ (which we did in induction base).

    Let $\varphi = \Pi_{X_1}\ldots \Pi_{X_k} \ c$ be a 1Q expression. Its corresponding sequence is defined as following: $a(n) = c^{2^{nk}}$. There are four possible kinds of quantification: $\Sigma_x$, $\Sigma_X$, $\Pi_x$, $\Pi_X$. Define sequences corresponding to 1Q expressions using these quantifiers:
    $$a_1(n) = n \cdot c^{2^{nk}} \text{ for } \Sigma_x \ \varphi,$$
    $$a_2(n) = 2^n \cdot c^{2^{nk}} \text{ for } \Sigma_X \ \varphi,$$
    $$a_3(n) = c^{2^{nk} \cdot n} \text{ for } \Pi_x \ \varphi,$$
    $$a_4(n) = c^{2^{n(k+1)}} \text{ for } \Pi_X \ \varphi.$$
    It is clear that $c^{2^{n(k+1)}} \geq c^{2^{nk} \cdot n}$ and $c^{2^{n(k+1)}} \geq 2^n \cdot c^{2^{nk}}$ and $c^{2^{n(k+1)}} \geq n \cdot c^{2^{nk}}$. From this follows any quantifier can be replaced by $\Pi_X$ quantifier to achieve sequence growing at least as fast. This concludes a proof by induction as we handled every form of QMSO expression.

    From this follows that for arbitrary 1Q expression $\varPsi$ it is possible to create an expression $\varPhi$ of form:
    $$\Pi_{X_1}\Pi_{X_2}\ldots \Pi_{X_k} \ c,$$
    for some $c$, depending only on $\varPsi$, such that sequence generated by $\varPsi$ is bounded by sequence generated by $\varPhi$. Sequence generated by $\varPhi$ is exactly $a(n) = c^{2^{kn}}$, which has doubly exponential rate of growth. This also shows that for arbitrary $c, k$ it is possible to achieve sequence $c^{2^{kn}}$.






%     We will show that every sequence generated by 1Q expression can be bounded by a sequence in a nice form, for which it will be easier to show the doubly exponential growth rate. We will build 1Q expressions generating sequences with maximal possible growth rate. We will analyze 1Q expressions of the form:
%     $$Q_{1Y_1}Q_{2Y_2} \ldots Q_{kY_k} \ . \ c$$
%     Where $Q_i \in \{ \Sigma, \Pi \}$ and each $Y_i$ is either first-order or second-order variable. There are $k$ semiring quantifiers, and then an expression without semiring quantification. Innermost expression is just a constant $c$ - it doesn't make sense to have any MSO expressions here, as those only filter out some variable evaluations. More precisely, let $\varphi$ be a quantifier-free 1Q expression. Then there exists $c$ such that:

%     \begin{equation}
%     \label{Ineq1}
%         Q_{1Y_1}Q_{2Y_2} \ldots Q_{kY_k} \ . \ \varphi \leq Q_{1Y_1}Q_{2Y_2} \ldots Q_{kY_k} \ . \ c   
%     \end{equation}
% \filip{pewnie powinno byc co do wartosci bezwzglednej? alek: to liczby naturalne wiec raczej bez znaczenia}
    
%     To explain this recall that
%     by \cref{QFreeRecognizable} we can assume that the formula $\varphi$ is a recognizable step function $\varphi = \sum_{i = 1}^{n} \ . \ \varphi_{L_i} \cdot k_i$. Each of $\varphi_{L_i}$ is either $0$ or $1$. To satisfy \cref{Ineq1} we set $c = \sum_{i=1}^n \ . \ |k_i|$. Clearly $\sum_{i = 1}^{n} \ . \ \varphi_{L_i} \cdot k_i \leq  \sum_{i=1}^n \ . \ |k_i|$, from which follows \cref{Ineq1}. We additionally assume that $c$ is not smaller than $2$, i.e.\ $c = max(2, \sum_{i=1}^n \ . \ |k_i|)$.

%     From now on, assume that semiring-quantifier-free expressions consist only of some constant.




%     Suppose we have quantification of depth $k$. There are four possible kinds of quantification: $\Sigma_x$, $\Sigma_X$, $\Pi_x$, $\Pi_X$. We argue that we can simplify the analysis to formulas using only $\Pi_X$ quantifications. It is because every quantifier $Q_{iY_i}$ aggregates values using sum (for $\Sigma$) or multiplication (for $\Pi$) of $n$ (for first-order variable) or $2^n$ (for second-order variable) identical subexpressions, each having value at least $2$. More formally:
%     $$\Sigma_x \ . \ c = n \cdot c$$
%     $$\Sigma_X \ . \ c = 2^n \cdot c$$
%     $$\Pi_x \ . \ c = c^n$$
%     $$\Pi_X \ . \ c = c^{2^n}$$

%     Clearly $c^{2^n} \geq c^n$ and $c^{2^n} \geq 2^n \cdot c$ and $c^{2^n} \geq n \cdot c$.\filip{to nie jest do konca poprawne, bo bedziesz chcial to aplikowac nie do $c$ tylko do podwyrazen. Trzeba pewnie napisac cos madrego przez indukcje. Aha i uzywaj slow zamiast $\land$ zwlaszcza w pracy o formulach logicznych}

%     Now we argue that it suffices to look at simplified expressions of form $\Pi_{X_1}\Pi_{X_2}\ldots \Pi_{X_k} \ . \ c$.
% %
%     Our simplified expression is in prenex normal form with regards to semiring quantification. We need to justify why every 1Q sequence can be bounded by sequence defined by an expression of such form. Let $\theta_1 = \Pi_{X1'} \ldots \Pi_{Xk'} \ . \ c_1$, $\theta_2 = \Pi_{X1''} \ldots \Pi_{Xk''} \ . \ c_2$ where $c_1, c_2 \geq 2$. Let $pref = \Pi_{X1}\Pi_{X2} \ldots \Pi_{Xk}$ be some quantifiers prefix, possibly empty. Then it can be seen that:\filip{nie rozumiem o co chodzi z pref}
%     $$pref \ . \ \theta_1 + \theta_2 \leq pref \ . \ \Pi_{X1'} \ldots \Pi_{Xk'} \Pi_{X1''} \ldots \Pi_{Xk''} \ . \ c_1 \cdot c_2$$
%     $$pref \ . \ \theta_1 \cdot \theta_2 \leq pref \ . \ \Pi_{X1'} \ldots \Pi_{Xk'} \Pi_{X1''} \ldots \Pi_{Xk''} \ . \ c_1 \cdot c_2$$
%     It follows from the fact that
%     $$\theta_1 + \theta_2 = (c_1)^{2^{k'n}} + (c_2)^{2^{k''n}} \leq (c_1 \cdot c_2)^{2^{(k' + k'')n}} = \Pi_{X1'} \ldots \Pi_{Xk'} \Pi_{X1''} \ldots \Pi_{Xk''} \ . \ c_1 \cdot c_2$$
%     and
%     $$\theta_1 \cdot \theta_2 = (c_1)^{2^{k'n}} \cdot (c_2)^{2^{k''n}} \leq (c_1 \cdot c_2)^{2^{(k' + k'')n}} = \Pi_{X1'} \ldots \Pi_{Xk'} \Pi_{X1''} \ldots \Pi_{Xk''} \ . \ c_1 \cdot c_2$$

%     This shows that we can bound expressions with addition and multiplication using greater quantification depth and we finish with prenex normal form expressions.

    % From this we see that for arbitrary 1Q expression $\varPsi$ we can create an expression $\varPhi$ of form:
    % $$\Pi_{X_1}\Pi_{X_2}\ldots \Pi_{X_k} \ . \ c$$
    % for some $c$, depending only on $\varPsi$, such that sequence generated by $\varPsi$ is bounded by sequence generated by $\varPhi$. Sequence generated by $\varPhi$ is exactly $a(n) = c^{2^{kn}}$, which has doubly exponential rate of growth. This also shows that for arbitrary $c, k$ it's possible to achieve sequence $c^{2^{kn}}$.
\end{proof}

\ifilip{ogolne uwagi: za duzo ``can''; nie powinno sie uzywac nieformalnego jezyka; nierownosci to czesc zdania (powinny sie konczyc kropka lub przecinkiem); podobnie jak cos wymieniamy jako itemy; kazde zdanie przeczytac i skrocic}

% \section{1Q sequences modular periodicity}
% In this section we'll analyze sequences created with 1Q expressions modulo $p$, for arbitrary $p$. In particular we want to answer following question: is every such sequence eventually periodic and how would we go about finding a period for given sequence?

% A sequence is eventually periodic if there exists $N, t$ such that for all $n \geq N$ $a(n) = a(n+t)$. That means: at some point sequence will start to be periodic.

% Before stating and proving a lemma about modular periodicity of 1Q sequences, let's introduce automata construction that we'll make use of. Suppose we have some NFA $A = \{Q, \Sigma, T, q_0, F\}$ accepting language $L$ and two natural numbers $p, k$. We want to create NFA $A'$ that accepts only those words from $L$ over which the number of runs $n$ in $A$ modulo $p$ is equal to $k$.

% Let's first do it for a simple case of finding words for which there is an even number of runs ($|runs| \ mod \ 2 = 0$):

% \begin{enumerate}
%     \item Duplicate each state $s \in Q$ in automaton $A$. For one original state we'll have two states: $s_u$ and $s_n$, for \textit{uneven} and \textit{even}.
%     \item Do a powerset construction as following. Initial state is $\{q_{0u}\}$. Suppose our current state is of form $S = \{s_{i_1u}, s_{i_2u}, \ldots, s_{i_ku}, s_{j_1e}, s_{j_2e}, \ldots, s_{j_le}\}$. Next state of automaton will be set $S'$, and some state $s'_e \in S'$ if there is an even, nonzero number of states $s \in \{s_{i_1u}, s_{i_2u}, \ldots, s_{i_ku}\}$ that have a transition $s \rightarrow s'$ in original automaton $A$, or there are no such states but there is state $s \in \{s_{j_1e}, s_{j_2e}, \ldots, s_{j_le}\}$ that has a transition $s \rightarrow s'$. State $s'_u \in S'$ if there is an uneven number of states $s \in \{s_{i_1u}, s_{i_2u}, \ldots, s_{i_ku}\}$ that have a transition $s \rightarrow s'$ in original automaton $A$.
%     \item We accept states $S$ in $A'$ for which the number $s_u \in S$, $s \in F$ is even and nonzero, or if it's zero and there's a state $s_e \in S$, $s \in F$. 
% \end{enumerate}

% Rationale for this construction is following: we start on initial state, having uneven number of runs. Then we collect in our state information about which states of original automaton we would end up on (just like in powerset construction), and also whether the number of runs passing through given state is even or uneven. We determine state transitions by just calculating the number of runs: having some state set $S$ of new automaton and some state $q$ of original automaton, we check the number of transitions from states of $S$ to $q$ in original automaton. A state $s_e \in S$ s.t. $(s, 'a', q) \in \Sigma$ is treated as even number of runs: 'there had been even number of runs that ended in $s$'. A state $s_u \in S$ s.t. $(s, 'a', q) \in \Sigma$ is treated as uneven number of runs. So the amount of runs ending in $q$ modulo 2 is determined by the number of such states $s_u$ - if there are evenly many of them, we'll have an even number of runs to $q$. Otherwise this number will be uneven.

% Set of accepting states for this automaton are those states $S$ which represent sets of accepting states from $Q$ to which we would have an even number of runs in original automaton.

% Explained construction can be adjusted to find words over which $|runs| \ mod \ p = k$. In this case we would create for each state $s \in Q$ states: $s_0, s_1, \ldots, s_{p-1}$ - each representing that the number of runs up to given state was equal to $i$ modulo $p$. Powerset construction and resulting set of accepting states would be analogous, but instead of counting modulo 2 (even, uneven), we would be counting modulo $p$.

% \begin{lemma}[1Q sequences modular periodicity]
% 1Q sequences modulo 2 are eventually periodic.
% \end{lemma}

% \begin{proof}
% Let's start with 1Q expressions without quantification on semiring level. In general such an expression has following form:
% $$\Psi = \varphi_1 \cdot c_1 + \varphi_2 \cdot c_2 + \ldots + \varphi_k \cdot c_k$$
% Where $\varphi_i$ is a 1 letter MSO expression and $c_i \in \mathbb{Q}$. It could also potentially have parts like $(\varphi_i \cdot c_i) \cdot (\varphi_j \cdot c_j)$, but it's just basically the same thing as $(\varphi_i \land \varphi_j) \cdot (c_i \cdot c_j)$, so we'll stick with just addition.

% A thing we'll use quite a lot is following simplification: instead of analyzing behavior of $\Psi$ modulo 2, let's just simplify it to $\Psi' = \varphi \cdot 1$. If we're able to do this simplification, we've proven lemma for expressions without quantification on semiring level: positions with value $1$ in our sequences are specified by language of $\varphi$. It's a regular language over $1$ letter alphabet so it's eventually periodic (TODO: explain?).

% Let's explain how we can go from $\Psi$ modulo $2$ to $\Psi'$. In the first step we can get rid of all constants $c_i$ that are divisible by $2$: they won't affect value modulo $2$. Resulting expression modulo $2$ is as following: $\varphi_1' \cdot 1 + \varphi_2' \cdot 1 + \ldots + \varphi_k' \cdot 1$. 

% $\varphi$ represents an automaton that on given input $a^n$ accepts if there is uneven number of automatons among $ A = \{\varphi_1', \ldots, \varphi_k'\}$ that accept $a^n$. Suppose automatons from set $A$ are deterministic (otherwise determinise them). We can create automaton $\varphi$ as following:
% \begin{enumerate}
%     \item Create an automaton $A_1$ that is an union of automatons from $A$. It is an undetereministic automaton.
%     \item Create an automaton $\varphi$ that accepts only those words accepted by $A_1$ for which the number of runs is uneven.
% \end{enumerate}

% Now suppose we have an expression with quantifiers on semiring level, namely of form $Q_{1Y_1}Q_{2Y_2} \ldots Q_{kY_k} \ . \ \varphi \cdot 1$
% \end{proof}

\section{1Q sequences over finite semirings}
\label{Sec1QFiniteSemirings}
Behavior of 1Q sequences modulo can help characterizing them and comparing with other classes of sequences. In this section we will show that 1Q sequences taken modulo $m$, $m \in \mathbb{N} - 0$, are eventually periodic.

\begin{definition}
    Let $a(n)$ be a sequence. $a(n)$ is \textit{eventually periodic} if there exists $N, p \in \mathbb{N}$, such that $\forall_{n \geq N} \ a(n) = a(n+p)$.
\end{definition}

This property shows limitations of 1Q sequences: they start behaving regularly from some point on. It's an effective method of checking if a sequence is 1Q-definable. For example, sequence of Catalan numbers is not eventually periodic, so it will be shown that it's not 1Q-definable. The goal of this section is proving following lemma:

\begin{lemma}
    \label{1QSequencesPeriodic}
    1Q sequences are eventually periodic modulo
\end{lemma}

First, we will characterize 1Q sequences modulo as 1Q sequences on modulo semiring:

\begin{lemma}
    \label{1QModulo}
    Given a sequence $a(n)$ defined by 1Q expression $\varphi$ over natural semiring $(\mathbb{N}, +, \cdot, 0, 1)$, a sequence $a(n) \mod m$, $m \in \mathbb{N} - \{0\}$, can be defined by 1Q expression $\varphi'$, such that:
    \begin{enumerate}
        \item $\varphi'$ is a 1Q expression over semiring $\mathbb{Z}_m = (\{0,\ldots,m-1\}, +_{mod}, \cdot_{mod}, 0, 1)$
        \item every constant $k$ appearing in $\varphi$ is replaced by $k \mod m$ in $\varphi'$
    \end{enumerate}
\end{lemma}

\begin{proof}
    Semantics of 1Q expressions consist of addition, multiplication, repeated addition and repeated multiplication (repeated in case of semiring quantifiers). This lemma is a direct consequence of properties of operations modulo:
    $$(a + b) \mod m = (a \mod m + b \mod m) \mod m$$
    $$(a \cdot b) \mod m = (a \mod m \cdot b \mod m) \mod m$$
\end{proof}

We will now prove a lemma about finite automata construction that will be useful later. It can be used to count number of runs of nondeterministic automaton.

\begin{lemma}
    \label{CountRunsAutomaton}
    Given a nondeterministic finite automaton $A$ recognizing language $L_A$ and natural numbers $m$, $k$, $k < m$, it's possible to create a finite automaton $C$ (as for \textbf{c}ounting automaton) recognizing language $L_{C} := \{ w : w \in L_A \land nRuns(A, w) \mod m = k \}$. $nRuns(A, w)$ returns number of runs of automaton $A$ over word $w$.
\end{lemma}

\begin{proof}
    We will create such an automaton $C$ using an extended powerset construction.

    Suppose original automaton $A$ had $n$ states, $Q_A = \{q_1, \ldots, q_n\}$. States of new automaton $C$, $Q_C$ will represent functions $f: Q_A \rightarrow \{0, \ldots, m-1 \}$. There are $m^n$ such functions, so is the number of states of $Q_C$. For state $q \in Q_C$ we will denote its corresponding function as $f_q$.
    
    Let $nRuns(A, w, q_i)$ be a function returning a number of runs of automaton $A$ over word $w$ finishing in state $q_i \in Q_A$. State $q \in Q_C$ represented by function $f_q$ will be interpreted as following:
    $$f_q(q_i) = nRuns(A, w, q_i) \mod m$$

    % \begin{equation*}
    %     f(q_i) =
    %       \begin{cases}
    %         -1 & \text{if $nRuns(A, w, q_i) = 0$} \\
    %         l, l \in $\{0, \ldots, m-1\}$ & \text{if $nRuns(A, w, q_i) = l \mod m$}
    %       \end{cases}       
    % \end{equation*}

    Now let's introduce initial state, final states and transitions of automaton $C$.

    Initial state of $C$ is a function mapping initial state of $A$ to $1$ and every other state to $0$.

    Suppose the set of final states of automaton $A$ is $F_A$. Let $q_C \in Q_C$. Define $sumFin(q_C) = \sum_{q \in F_A} \ f_{q_C}(q)$. $sumFin$ returns sum of values of function corresponding to given state $q_C$ over all final states of $A$. Now, final states of $C$, $F_C \subseteq Q_C$, are states $q_C$ for which $sumFin(q_C) = k \mod m$. Intuitively, final states of $C$ are states in which we accept a word $k \mod m$ times.

    Lastly, we need to define transitions of $C$. Suppose the set of transitions of automaton $A$ is $\delta_A$ and set of transitions of automaton $C$ is $\delta_C$. Let $q_C^1, q_C^2$ be two states of $C$, $f_1, f_2$ their corresponding functions. $q_C^1 \xrightarrow{a} q_C^2 \in \delta_C$ if 
    $$f_2(q_i) = (\sum_{q \in Q_A} \ \text{if } q \xrightarrow{a} q_i \text{ then } f_1(q) \text{ else } 0) \mod m$$

    Intuitively, we count the number of runs ending in given state $q_i$ by summing over all states that have a transition to this state over given letter from previous state.

    Now let us prove correctness of this construction. We will prove that after reading input word $w$, we reach state $q_C$ in automaton $C$, for which a function $f_{q_C}$ correctly calculates number of runs over word $w$ ending in given states in automaton $A$ (modulo $m$). From this and construction of final states of $C$ it will be clear that the construction is correct.

    We will prove it by induction on length of word $w$.
    In base case consider an empty word $\epsilon$. $C$ accepts this word only if following conditions occur:
    \begin{itemize}
        \item some final state of $A$ is also an initial state of $A$
        \item $k = 1$
    \end{itemize}
    This follows from definition of initial and final states of $C$.
    
    For induction step, assume that construction is correct for a word of length $n-1$, $w_1 \ldots w_{n-1}$. That is, after reading first $n-1$ letters, we end up in a state $q_C \in Q_C$ represented by a function $f_{q_C}$ that correctly assigns numbers of runs (modulo $m$). We want to show that after reading next letter (so having a word of length $n$), $C$ reaches a state that also correctly assigns numbers of runs. For some state $q \in Q_A$, to find a number of runs finishing in $q$ after reading a word $w = w_1\ldots w_{n-1}w_n$, we need to consider all the states $q_{prev} \in Q_A$ such that $(q_{prev} \xrightarrow{w_n} q) \in \delta_A$ - all the states from which $q$ can be reached over last letter in word. Thanks to induction assumption, we know the numbers of runs ending in those states $q_{prev}$ after reading $w_1 \ldots w_{n-1}$. From this it's clear that the number of runs finishing in state $q$ after reading $w$ can be expressed by following formula:
    $$(\sum_{q \in Q_A} \ \text{if } q \xrightarrow{a} q_i \text{ then } f_{q_C}(q) \text{ else } 0) \mod m$$
    Which is exactly how we defined transition function of $C$.

    % \begin{equation*}
    %     f_2(q_i) =
    %       \begin{cases}
    %         -1 & \text{if there is no $q \in Q_A$ such that $q \xrightarrow{a} q_i$} \\
    %         \Sigma_{q \in Q_A} \ . \ \text{if } q \xrightarrow{a} q_i \text{ then } max(f_1(q), 0) \text{ else } 0 & \text{otherwise}
    %       \end{cases}       
    % \end{equation*}


    % $$f_2(q_i) = \Sigma_{q \in Q_A} \ . \ \text{if } q \xrightarrow{a} q_i \text{ then } max(f_1(q), 0) \text{ else } 0$$
\end{proof}

This lemma will be used to prove that it's possible to remove quantifiers from 1Q expressions and simplify those expressions. 

First, it will be necessary to specify encoding of words accepted by MSO expressions with free variables. We will use method explained in \cite{KreutzerR13}. The 'base' alphabet is still 1 letter alphabet $\Sigma = \{a\}$. Now, let $\varphi$ be a MSO expression with non empty set of free variables (first and second order) $V$. A word accepted by $\varphi$ is a word over alphabet $\Sigma_V = \Sigma \times \{0, 1\}^{|V|}$. Let $w$ be some word over $\Sigma$ and $\sigma$ a $(V, w)$ assignment. A word $(w, \sigma) \in \Sigma_V$ \textit{encodes} a $(V, w)$ projection if $w$ is the projection of $(w, \sigma)$ over $\Sigma$ and for every variable $v \in V$ we have $\sigma(v) = \{i \in \{1,\ldots,|w|\} \ | \ (w, \sigma)[v]_i = 1 \}$ where $(w, \sigma)[v]_i$ denotes the $i$-letter of the projection $(w, \sigma)$ over variable $v$.

\begin{example}
    Suppose we have an expression with one free first order variable:
    $$\varphi = \forall x \ y \leq x.$$
    In this case $y$ can only be the first position. Language recognized by this expression can be expressed with following regular expression: $\epsilon + (a,1)(a,0)^*$.
\end{example}

In following steps it will be convenient to work with finite automata instead of MSO expressions. It's known (\cite{Buchi1960}) that for every MSO expression it's possible to build a finite automaton accepting the same language and vice versa.

We will use notion of simple recognizable step functions, which are an extension of recognizable step functions (\ref{DefRecStepFun}).

\begin{definition}[Simple recognizable step function]
    \label{DefSimpleRecStepFun}
    A \textit{simple recognizable step function} is a recognizable step function $S = \sum_{i = 1}^{n} \ \varphi_{L_i} \cdot k_i$ in which languages $\{L_i : i \in \{1,\ldots,n\}\}$ form a partition of whole language $\Sigma^* = \dot{\bigcup}_i \ L_i$.
\end{definition}

A recognizable step function can be transformed into simple recognizable step function:

\begin{lemma}
    \label{RecEqSimpleRec}
    Recognizable step functions and simple recognizable step functions are the same functions.
\end{lemma}

\begin{proof}
    Suppose we have a recognizable step function $S = \sum_{i = 1}^{n} \ \varphi_{L_i} \cdot k_i$. We can create a simple recognizable step function defining the same function. Let $P$ be a powerset of $N = \{1,\ldots,n\}$. Then a simple recognizable step function can be defined in following way:
    $$S = \sum_{I \in P} \ (\bigwedge_{i \in I} \varphi_{L_i} \bigwedge_{j \in (N-I)} \neg \varphi_{L_j}) \cdot (\sum_{i \in I} \ k_i)$$
    Expression $(\bigwedge_{i \in I} \varphi_{L_i} \bigwedge_{j \in (N-I)} \neg \varphi_{L_j})$ is true for exactly one $I \in P$ for given input $w$ - it follows from law of excluded middle. Now, to calculate value appearing in this intersection, we add constants corresponding to true expressions. This gives us a simple recognizable step function which calculates the same values as original recognizable step function.

    A simple recognizable step function is a recognizable step function by definition, so it doesn't require a proof.
\end{proof}

Following lemmas are crucial in semiring quantifiers elimination in 1Q expressions:

\begin{lemma}
    \label{QuantElimAdd}
    Let $\mathbb{Z}_m$ be a modulo semiring and $\varphi$ a simple recognizable step function on this semiring. Then $\Sigma_x \ \varphi$ and $\Sigma_X \ \varphi$ are also simple recognizable step functions.
\end{lemma}

\begin{proof}
    $\varphi$ is a simple recognizable step function, so it can be expressed as $\varphi = \sum_{i = 1}^{n} \ \varphi_{L_i} \cdot k_i$, where $\varphi_{L_i}$ are MSO expressions and $k_i \in \mathbb{Z}_m$. Now, consider the expression $\Sigma_{X} \ \varphi$, where $X$ is either a first-order or second-order variable. The reasoning is the same regardless of whether we work with first-order or second-order variables, so we will handle both simultaneously. Some of the MSO expressions inside $\varphi$ might contain $X$ as a free variable, while others might not. Nevertheless, in semantics of QMSO, $\Sigma$ will iterate over all valuations of $X$ to evaluate this expression. We can assume that every MSO expression inside $\varphi$ contains $X$ as a free variable, by simply concatenating every expression with the always true expression $X = X$.

    Now, for every MSO expression $\varphi_{L_i}$ appearing inside $\varphi$, assign a deterministic finite automaton recognizing the same language. These MSO expressions the contain free variable $X$, so corresponding automata are defined over an extended alphabet. Next, modify these automata by changing the alphabet: remove the position from alphabet corresponding to the valuation of variable $X$. This is a similar method to the one used in proving that finite automata coincide with MSO expressions. After changing the alphabet we turned deterministic finite automata into nondeterministic finite automata that guesses valuations of free variable $X$ - each accepted run for given word over reduced alphabet corresponds to some accepting valuation of $X$. Consequently, the number of runs of modified automaton is the number of accepting valuations of $X$.

    To handle addition - semiring quantifiers $\Sigma$ - it is only necessary to know how many times (modulo $m$) each constant $k_i$ appears. Count the number of runs (valuations) for automaton corresponding to $\varphi_{L_i}$ using lemma \ref{CountRunsAutomaton}. For every $\varphi_{L_i}$ and every $k < m$, create an automaton $\varphi_{L_i}^k$, accepting words over the reduced alphabet (i.e., without valuation of $X$) for which the number of accepting valuations in the original automaton was equal to $k \mod m$. Now, addition quantifiers can be removed in following way:
    $$\Sigma_x \ \varphi = \sum_{i = 1}^n \sum_{j = 0}^{m-1} \ \varphi_{L_i}^j \cdot (j \cdot k_i \mod m)$$
    $$\Sigma_X \ \varphi = \sum_{i = 1}^n \sum_{j = 0}^{m-1} \ \varphi_{L_i}^j \cdot (j \cdot k_i \mod m)$$
    $\varphi_{L_i}^j$ can be true for at most one $j$, $0 \leq j \leq m-1$. This $j$ marks the number of successful runs modulo $m$, that is, the number of valuations of $x$ (or $X$) for which $\varphi_{L_i}$ was true. In the original expression, we would add $k_i$ for each such valuation, giving us $j \cdot k_i$ for this part of the expression. Since we work modulo $m$, every such value is taken modulo $m$.
\end{proof}

\begin{lemma}
    \label{QuantElimMult}
    Let $\mathbb{Z}_m$ be a modulo semiring and $\varphi$ a simple recognizable step function on this semiring. Then $\Pi_x \ \varphi$ and $\Pi_X \ \varphi$ are also simple recognizable step functions.
\end{lemma}

\begin{proof}
    Proof for this lemma will use similar reasoning to that in~\cref{QuantElimAdd}, but with additional complexity. Once again, we need to determine how many times each constant $k_i$ appears across all valuations of variable bound by quantifier. However, it is insufficient to know how many times this constant appears modulo $m$, as in the case of exponentiation modulo, different numbers have different periods. For example, consider constant $2$ when working modulo $3$. We have $2^1 \mod 3 = 2$, $2^2 \mod 3 = 1$, $2^3 \mod 3 = 2$, and so on. For odd exponents, the value will always be $2$, and for even exponents, it will be $1$. Therefore, in this case, we need to know the number of valuations modulo $2$, not $3$. 

    It is also different for constants that are roots of any order of $m$. Suppose we work modulo $m = 16$ and we have a constant $k_i = 2$. Now, $2^1 \mod 16 = 2$, $2^2 \mod 16 = 4$, $2^3 \mod 16 = 8$, $2^4 \mod 16 = 0$, $2^5 \mod 16 = 0$, and so on. Thus, after reaching $2^4$, for all subsequent exponents, the value will be $0$. In this case we have a prefix sequence $2,4,8$, followed by a constant sequence of $0$.

    Both cases need to be handled. Start with the second one, i.e., when $k_i$ is a root of order $p_i$ of $m$. Define $p_i$ new MSO expressions and constants. Suppose we want to remove the quantifier $\Pi_X \ \varphi$, where X is either a first-order or second-order variable. Then $\varphi_{L_i}^j$ for $1 \leq j < p_i$ will express that there exist exactly $j$ different valuations of $X$ for which $\varphi_{L_i}$ is true. For $j = p_i$, $\varphi_{L_i}^j$ expresses that there are (at least) $p_i$ different valuations of $X$. Constants will be defined in following way: $k_i^j = (k_i)^j \mod m$, for $1 \leq j \leq p_i$. It follows from the fact that $k_i$ is a root of order $p_i$ of $m$ that $k_i^j = 0$ for $j = p_i$.

    For first case, i.e., $k_i$ is not a root of $m$ and the values $(k_i)^j \mod m$ form a cycle, we need to proceed as follows. For every such constant $k_i$ appearing in $\varphi$, we need to find its period $p_i$ modulo $m$ with respect to exponentiation. This period will be no greater than $m$, as sequence $a(n) = (k_i)^n \mod m$ can achieve at most $m$ different values before repeating. Define $k_i^j = (k_i)^j \mod m$, for $1 \leq j \leq p_i$. Now we can apply reasoning similar to the addition case: we create automata $\psi_{L_i}^{j}$ for $1 \leq j \leq p_i$. The expression $\psi_{L_i}^{j}$ accepts a language of words for which number of runs (valuations) modulo $p_i$ is $j$. However, in this case, we need to handle the special situation where there zero accepting valuations (as opposed to zero modulo $p_i$). We want $\varphi_{L_i}^j$ to be false in this case, for every $j$. To achieve this, define the expression: $\varphi_{L_i}^j = \psi_{L_i}^{j} \land \exists_{X} \ \varphi_{L_i}$, where $X$ is a first-order or second-order variable, depending on the type of quantifier we are eliminating.

    From what we already have, the value corresponding to some $k_i$ of the original expression, after quantifier elimination, is $\sum_{j = 1}^{p_i} \ (\varphi_{L_i}^j \cdot k_i^j)$. The inner MSO expression $\varphi_{L_i}^j$ will be true for at most one $j$. It will not be true for any $j$ if there are zero accepting valuations. In this case, $\sum_{j = 1}^{p_i} \ (\varphi_{L_i}^j \cdot k_i^j)$ will be zero. It will be more convenient if we had one in this case, as one is a neutral element with respect to multiplication. To achieve this, we will use the following expression for a given constant $k_i$: $(\sum_{j = 1}^{p_i} \ \varphi_{L_i}^j \cdot k_i^j) + (\neg \exists_X \ \varphi_{L_i})$
    
    Now, multiplication quantifiers can be removed in following way:
    $$\Pi_x \ \varphi = \prod_{i = 1}^n \ (\sum_{j = 1}^{p_i} \ \varphi_{L_i}^j \cdot k_i^j) + (\neg \exists_x \ \varphi_{L_i})$$
    $$\Pi_X \ \varphi = \prod_{i = 1}^n \ (\sum_{j = 1}^{p_i} \ \varphi_{L_i}^j \cdot k_i^j) + (\neg \exists_X \ \varphi_{L_i})$$
\end{proof}

Finally, we can characterize 1Q sequences on a modulo semiring as simple recognizable step functions:

\begin{lemma}
    \label{OverModAreSimpleRec}
    Let $\mathbb{Z}_m$ be a modulo semiring and $\varphi$ be a 1Q sentence over $\mathbb{Z}_m$. Then a sequence defined by $\varphi$ can be defined as a simple recognizable step function (i.e. $\varphi$ can be reduced to a form of simple recognizable step function) 
\end{lemma}

\begin{proof}
    We use induction on the structure of expression $\varphi$. For base case - expressions without quantification at the semiring level - it follows from lemmas~\ref{QFreeRecognizable} and~\ref{RecEqSimpleRec}. 
    
    Sum and product of two simple recognizable step functions is a simple recognizable step function - it follows from induction step of proof of~\cref{DefRecStepFun} and from~\cref{RecEqSimpleRec}.

    Consider an expression $\varphi = Q_Y \ \theta$, where $\theta$ is a simple recognizable step function, $Q$ a semiring quantifier and $Y$ first order or second order variable. By lemmas~\ref{QuantElimAdd} and~\ref{QuantElimMult} it follows that $\varphi$ is a simple recognizable step function. This finishes the proof.
\end{proof}

\begin{lemma}
    \label{InvAreReg}
    Inverse images of simple recognizable step functions are regular languages
\end{lemma}

\begin{proof}
    This follows directly from definition. Let $\varphi = \sum_{i = 1}^{n} \ \varphi_{L_i} \cdot k_i$ be a simple recognizable step function. Then $\varphi^{-1}(k_i) = \varphi_{L_i}$, where $\varphi_{L_i}$ specifies a regular language.
\end{proof}

From these results, an important characterization of 1Q sequences on modulo semirings follows: 1Q sequences on modulo semirings are eventually periodic.



% \begin{lemma}
%     Let $L$ be a regular language on 1-letter alphabet with infinite number of words. Define a sequence of natural numbers $a(n)$ in following way:
%     \begin{equation*}
%         a(n) =
%           \begin{cases}
%             1 & \text{if $a^n \in L$}\\
%             0 & \text{otherwise}
%           \end{cases}       
%     \end{equation*}
%     Then $a(n)$ is an eventually periodic sequence.
% \end{lemma}

% \begin{proof}
    
% \end{proof}

\begin{lemma}
    \label{OverModAreSimpleRec2}
    Let $\mathbb{Z}_m$ be a modulo semiring and $\varphi$ be a 1Q sentence over $\mathbb{Z}_m$. Then a sequence defined by $\varphi$ is eventually periodic.
\end{lemma}

\begin{proof}
    Thanks to~\cref{OverModAreSimpleRec} we know that $\varphi$ reduces to simple recognizable step function. Additionaly, by~\ref{InvAreReg}, we know that language of words for which sequence defined by $\varphi$ achieves a given value $k_i$ is a regular language. There is a finite number of values this sequence can achieve (at most $m$). Regular languages on one-letter alphabets are eventually periodic with regard to word length (\cite[Theorem 1]{PighizziniS02}).

    There are $m$ regular, disjoint languages $L_1, \ldots, L_m$ corresponding to different constants $k_i$. We assume these languages don't accept empty word. Each language $L_i$ is eventually periodic with regard to word length, so there exist $N_i, p_i \in \mathbb{N}$, such that $\forall_{n \geq N_i} \ a^n \in L_i \iff a^{n + p} \in L_i$. To find a ``global'' period that works for all langauges, take $N = \prod_{i=1}^m \ N_i$, $p = \prod_{i=1}^m \ p_i$. This period is simultaneously a period for every $L_i$ since $N$ divides each $N_i$ and $p$ divides each $p_i$.
\end{proof}

From this, the main result of this section,~\cref{1QSequencesPeriodic}, directly follows:

\begin{proof}[Proof of~\cref{1QSequencesPeriodic}]
    1Q sequences modulo are the same as 1Q sequences over a modulo semiring (\cref{1QModulo}). The result then follows directly from~\cref{OverModAreSimpleRec2}.
\end{proof}

\begin{corollary}
    Catalan numbers are not 1Q-definable
\end{corollary}

\begin{proof}
    Reasoning is the same as in \cite[Theorem 7, Corollary 8]{CadilhacMPPS20} - Catalan numbers are not ultimately periodic modulo prime numbers $p > 3$, while 1Q-definable sequences are. Therefore, Catalan numbers are not 1Q-definable.
\end{proof}

% \section{1Q sequences over finite semirings v2}
% In order to compare 1Q sequences with other classes of sequences, it's useful to consider what is the behavior of these sequences modulo arbitrary natural numbers.

% \begin{lemma}[1Q sequences modulo]
%     Given a sequence $a(n)$ defined by 1Q expression $\varphi$ over natural semiring $(\mathbb{N}, +, \cdot, 0, 1)$, a sequence $a(n) \mod c$, $c \in \mathbb{N} - \{0\}$, can be defined by 1Q expression $\varphi'$, such that:
%     \begin{enumerate}
%         \item $\varphi'$ is a 1Q expression over semiring $(\{0,\ldots,c-1\}, +, \cdot, 0, 1)$, where addition and multiplication are done modulo $c$
%         \item every constant $k$ appearing in $\varphi$ is replaced by $k \mod c$ in $\varphi'$
%     \end{enumerate}
% \end{lemma}

% \begin{proof}
%     Proof!!
% \end{proof}

% Knowing this we can characterize behavior of 1Q sequences modulo - those are sequences defined by 1Q expressions over finite semirings. It would be useful to know if it's possible to define inverse images of finite semirings. For this, a definition of recognizable step function is useful (FROM DROSTE PAPER).

% \begin{definition}[Recognizable step function]
%     Series $S: A^* \rightarrow K$ is a \textit{recognizable step function}, if $S = \sum_{i = 1}^{n} \ . \ \varphi_{L_i} \cdot k_i$ for some $n \in \mathbb{N}$, $k_i \in K$ and regular languages $L_i \subseteq A^*$ ($i=1,\ldots,n$). $\varphi_{L_i}$ is an MSO formula recognizing language $L_i$.
% \end{definition}

% It would be simpler if languages $\{L_i : i \in \{1,\ldots,n\}\}$ were disjoint, so that we don't need to do any addition. For this we can define \textit{simple recognizable step functions}:

% \begin{definition}[Simple recognizable step function]
%     A \textit{simple recognizable step function} is a step function $S = \sum_{i = 1}^{n} \ . \ \varphi_{L_i} \cdot k_i$ in which all languages $\{L_i : i \in \{1,\ldots,n\}\}$ are disjoint.
% \end{definition}

% A recognizable step function can be transformed into simple recognizable step function:

% \begin{lemma}
%     Recognizable step functions and simple recognizable step functions are the same functions.
% \end{lemma}

% \begin{proof}
%     Suppose we have a recognizable step function $S = \sum_{i = 1}^{n} \ . \ \varphi_{L_i} \cdot k_i$. We can create a simple recognizable step function defining the same function in following way: ... TODO
% \end{proof}

% We can now characterize 1Q sequences modulo behavior:

% \begin{lemma}
%     1Q sequences modulo are simple recognizable step functions
% \end{lemma}

% \begin{proof}
%     Droste says:
%     \begin{enumerate}
%         \item Series definable by weighted automata over finite semirings are recognizable step functions
%         \item Series definable by QMSO sentences over finite semirings are the same as series definable by weighted automata over finite semirings
%     \end{enumerate}
%     We know that 1Q sequences modulo are defined by 1Q expressions over finite semirings, so in particular those are recognizable step functions. So they are simple recognizable step functions.
% \end{proof}

% \begin{corollary}
%     Inverse images of values of 1Q sequences modulo are regular languages
% \end{corollary}

% \begin{corollary}
%     1Q sequences modulo are ultimately periodic
% \end{corollary}

% \begin{corollary}
%     Catalan numbers sequence is not 1Q-definable
% \end{corollary}

% \section{1Q sequences modulo constant 0}

% \section{1Q on first order logic}
% It might be interesting to look into following restriction of 1Q expressions: we can only use first order variables on semiring level and logical level (i.e. we move from MSO logic to FO logic). 

% First, let's focus on behavior of these sequences modulo.

% As stated in Droste paper, first order definable series coincide with series definable by weighted automata when working with aperiodic semirings. Unfortunately, semirings we're working with - semirings for modulo operations - aren't aperiodic. It can be easily with sequence defined by following expression:

% $$ \Sigma_x \ . \ 1 $$

% It defines the following sequence modulo 2: $\{1, 0, 1, 0, 1, \ldots\}$, which is not aperiodic. What's even more interesting is that inverse images of values of this sequence are not FO-definable languages. For value $0$ inverse image is a language of words of even length, which is only definable in second order logic. 

% We might want to ask if it's possible to define following sequence in 1Q modulo 2 using FOL: $\{0, 0, 1, 0, 0, 1, \ldots\}$, that is: we have ones on positions divisible by 3. 

\bibliographystyle{plainurl}
\bibliography{bib}

\end{document}
